### 问题列表
1. get和head的区别
2. post和put的区别
3. 204和304的区别
4. js的gc机制

### 解答
1. get  : 请求指定uri的资源,包括实体主体(响应主体request body)  
   head: 请求指定uri的资源,返回响应头(不包括响应主体和响应协议头)  
   应用场景: get用于信息获取,是安全和幂等的(不产生副作用，对服务器的资源uri的改变可预测)  
            head用于搜索引擎(搜索量级太大，只需要返回搜索条数，服务端可以插入自定义响应头，前端不需要获取响应主体，只需要获取响应头的条数数据即可)，语义化是用于获取响应头，不需要获取响应主体

2. post : 请求服务器接受所指定的文档作为对所标识的URI的新的从属实体(请求修改服务器资源)  
   put  : 从客户端向服务器传送的数据取代指定文档的内容  
   应用场景: post用于服务器资源修改，不安全和不幂等，会产生副作用，只更新部分资源uri，数据可以包含在请求主体里面(get请求只能将数据作为querystring附带在url中，可传输数据量有限)  
            put和post区别在语义上，put指的是替换资源，需要client提交资源全部信息去替换服务器资源(put请求x.com，传输a，那通过get请求的时候，应该是返回a。如果是post请求，则服务端可以有副作用，可能对uri资源作修改，如a->b)，可用于传输文件的语义化请求(替换uri)。语义化是对服务器uri进行可预测的修改(替换) 
        
3. 204: no content，请求执行成功，但是没有数据，节省request body的数据传输(和head请求的区别是，head请求语义化是请求资源)。具体可用于表单提交(定义action为xxx.com)，提交后返回204，则浏览器不跳转解析，只通过返回码判断提交成功。语义化是不需要响应主体的响应。
   304: not modified 请求复用缓存，页面会重新跳转，加载资源和渲染页面

4. js的两种gc机制  
    标记清除: 一定时间间隔的垃圾收集内，在运行的时候对存储在内存中的变量都加上标记(进入环境的标记)，去除掉在环境中的变量和被环境中变量引用的变量的标记(闭包，所以闭包不会被重新标记清除，如果函数内引用了闭包变量，那么就会除去函数变量fn和引用的闭包变量不会再被标记，保留在特殊栈中)，此后被标记的变量视为被要被清除的变量(离开环境的标记)
    引用计数: 追踪每个变量被引用的次数，当引用次数变成0，就回收内存空间,低版本的IEDOM和BOM采用引用计数(手动消除对需要消除dom对象的引用,xxx = null来手动减少引用次数来gc)

#### ps:对幂等的理解
客户端这边可以决定服务器uri的值(get,put，head)，对服务器资源uri的改变可预测(等同函数式编程，输入对应可确定的输出)，对这个请求(client发出的)就是幂等的，也可以缓存下来(get，head，put这些我在服务端可以设置缓存，因为返回的值是可预测的)  
如果服务端对uri有副作用(post)，则这个请求不幂等